# **Задание 1.1**

1. Описание функциональности текущего монолитного приложения.

**API**
- **getHeatingSystem** — Получение системы отопления по id
- **updateHeatingSystem** — Обновление системы отопления по id
- **turnOn** — Включение системы отопления по id
- **turnOff** — Выключение системы отопления по id
- **setTargetTemperature** — Установка целевой температуры до tmp для системы отопления по id
- **getCurrentTemperature** — Получение текущей температуры для системы отопления по id

**Текущее монолитное приложение имеет ряд проблем:**
- Нет чётких границ между пользовательским взаимодействием с системой и тем, как система сама выполняет внутренние взаимодействия.
- Синхронное взаимодействие с датчиками. Датчики могут быть временно недоступны, из-за чего вся система будет ждать. Если домов, где расположены датчики, много, то высока вероятность того, что какие-то датчики будут недоступны.
- Синхронное управление температурой. Пользователю не нужно ждать, пока запрос дойдёт до датчика и обратно. В периоды высокой нагрузки, например, во время резких изменений климата или в утренние и вечерние часы, когда пользователи корректируют температуру, могут возникать проблемы с производительностью.
- Одна база данных для всего приложения. Данные для мониторинга и управления отоплением хранятся вместе. Объём данных по температуре может быть в несколько раз больше, чем данных по системам, что может негативно сказаться на производительности.

**Плюсы текущей архитектуры:**

- Удобна для небольшого количества пользователей. Возможно, пока пользователей не так много, сервис будет справляться со своими задачами и не вызывать проблем с производительностью. Не нужно поддерживать большое количество отдельных микросервисов, инструментов масштабирования и оркестрации.
- В текущем приложении мало кода, соответственно, на данном этапе разработка нового функционала осуществляется быстро.

**Минусы текущей архитектуры:**

- Сложность масштабирования. При росте количества датчиков, подключённых к системе, высок риск ухудшения производительности.
- Рост количества запросов в одну часть системы может негативно влиять на другие части. Например, во времена высокой активности при изменении параметров системы отопления могут возникать задержки при получении данных о текущей температуре с датчиков.


#### Описание текущей реализации

### Домен: Управление системой отопления
Этот домен отвечает за все действия, связанные с управлением системой отопления, включая включение и выключение системы
- **Поддомен: Управление отоплением**
  Этот поддомен фокусируется на включении и выключении системы отопления. Его задачи связаны с управлением состоянием системы (включено/выключено)
    - Контекст: Включение системы отопления
    - Контекст: Выключение системы отопления
- **Поддомен: Управление температурой**
  Этот поддомен сосредоточен на задачах, связанных с установкой пользователем целевой температуры и её поддержанием системой.
    - Контекст: Установка целевой температуры пользователем
    - Контекст: Автоматическая регулировка температуры системой
### Домен: Мониторинг температуры
Этот домен отвечает за сбор данных с датчиков температуры и предоставление этих данных пользователям. Он занимается только мониторингом и не вмешивается в управление самой системой отопления (включение, выключение, установка температуры).
- **Поддомен: Сбор данных с датчиков**
  Этот поддомен занимается непосредственно взаимодействием с датчиками, которые установлены в домах пользователей. Его задача — получать данные о текущей температуре.
    - Контекст: Получение температуры с датчиков, установленных в домах
- **Поддомен: Отображение данных пользователям**
  Этот поддомен отвечает за вывод данных о текущей температуре пользователям. Он не вмешивается в работу датчиков, его задача — показать информацию в интерфейсе.
    - Контекст: Отображение текущей температуры на пользовательском интерфейсе (UI)


# **Задание 1.2**

### Декомпозиция на микросервисы

**Сервис "Управление устройствами"**
Контекст: Регистрация/Авторизация пользователей
Entities:
- User — сущность пользователь
Repositories:
- UserRepository — интерфейс для доступа к данным пользователей
Services:
- UserService — сервис для работы с пользователями

Контекст: Регистрация/Удаление девайса в системе
Entities:
- Device — объект представляющий устройство
- User — сущность пользователь
- Home — сущность дома
Value objects:
- DeviceType — тип устройства
- DeviceCapabilities — объект-значение, который может хранить список поддерживаемых команд и состояний для каждого устройства
Aggregate:
-  Device — аггрегат представленный в виде сущности Device и типа устройства DeviceType
Repositories:
- DeviceRepository — интерфейс для доступа ко всем зарегистрированным девайсам в системе
- DeviceConnector — интерфейс для общения с девайсами
Services:
- DeviceRegistrationService — сервис регистрации/удаления девайсов в системе

**Контекст: Включение/Выключение устройства**  
Entities:
- Device — объект представляющий девайс
Value objects:
- DeviceStatus — текущий статус (включен/выключен) девайса
Aggregate:
- Device — аггрегат объединяющий сущность Device и объект-значение DeviceStatus
Repositories:
- DeviceRepository — интерфейс для доступа ко всем зарегистрированным девайсам в системе
- DeviceConnector — интерфейс для общения с девайсами
Services:
- DeviceControlService — сервис управления девайсами в системе

**Контекст: Установление целевого состояния для девайса**
Entities:
- Device — объект представляющий девайс
Value objects:
- CurrentDeviceState — текущее состояние девайса
- TargetDeviceState — целевое состояние девайса
Aggregate:
- Device — аггрегат объединяющий сущность Device, объекты-значение CurrentDeviceState и TargetDeviceState
Repositories:
- DeviceRepository — интерфейс для доступа ко всем зарегистрированным девайсам в системе
- DeviceConnector — интерфейс для общения с девайсами
Services:
- DeviceControlService — сервис управления девайсами в системе

**Контекст: Автоматическое регулирование состояния девайса**
Entities:
- Device — объект представляющий девайс
Value objects:
- CurrentDeviceState — текущее состояние девайса
- TargetDeviceState — целевое состояние девайса
Aggregate:
- Device — аггрегат объединяющий сущность Device, объекты-значение CurrentDeviceState и TargetDeviceState
Repositories:
- DeviceRepository — интерфейс для доступа ко всем зарегистрированным девайсам в системе
- DeviceConnector — интерфейс для общения с девайсами
Services:
- DeviceRegulationService — сервис регулирования состояниями девайсов

**Сервис "Управление телеметрией"**
**Контекст: Сбор телеметрии**
Entities:
- TelemetryRecord — объект телеметрии
- Device — девайс
  Value objects:
- TelemetryData — объект-значение, содержащий конкретные параметры устройства
  Repositories:
- TelemetryRepository — интерфейс для сохранения данных телеметрии в хранилище.
Services:
- TelemetryCollectionService — сервис, отвечающий за сбор телеметрии с устройств и передачу её в хранилище

**Контекст "Предоставление телеметрии пользователю"**
Entities:
- TelemetryView — сущность, представляющая данные для отображения пользователю.
Repositories:
- TelemetryRepository — интерфейс для получения данных телеметрии для отображения пользователю.
Services:
- TelemetryDisplayService — сервис для предоставления данных телеметрии в интерфейсе пользователя.


Выбор Технологий:
1) Сервис "Управление устройствами" — реляционная СУБД PostgreSQL будет использоваться для хранения данных о пользователях и устройствах. 
Так как необходима транзакционность и быстрое чтение/запись данных.

2) Сервис "Управление телеметрией" — для хранения данных телеметрии будет использоваться Time Series Database TimescaleDB.
Так как данные телеметрии имеют временную привязку и их объем может быть очень большим.

3) Для реализации асинхронного взаимодействия между сервисами будет использоваться Apache Kafka. 

P.S: Для базовой авторизации и регистрации добавлен контекст Регистрации/Авторизации пользователей в сервис "Управление устройствами".
Понятно, что это не идеальное решение и лучше вынести это в отдельный сервис. Но так как в задании не было описано, что это должен быть отдельный сервис, я добавил его сюда.
При последующих неудобствах данный контекст можно будет вынести в отдельный микросервис.


**1.3 Сущности** в сервисе "Управление устройствами"
1) User: пользователь системы
   - id — идентификатор пользователя
   - username - имя пользователя
   - email - почта
   - password_hash - хэш пароля
   - created_at
   - updated_at

2) Home: сущность дома, где будут находиться устройства
   - id - идентификатор дома
   - name — системное имя дома в виде "home_moscow_123"
   - description — описание дома для отображения на фронтенде
   - user_id — айди пользователя, который владеет данным домом
   - address — адрес
   - created_at
   - updated_at

3) Device
   - id — идентификатор девайса
   - name — системное имя девайса "temperature_regulator"
   - description — описание девайса "Регулирует температуру в доме"
   - attributes — атрибуты девайса. Текущее значение параметров, которыми позволяет управлять устройство {"temperature" : "25"}
   - home_id — дом, в котором находится устройство
   - status — статус девайса (вкл/выкл)
   - type — тип девайса
   - created_at
   - updated_at

**Сущности в сервисе "Телеметрия"**
1) TelemetryRecord: запись телеметрии по конкретному датчика
   - id — идентификатор запись
   - telemetry_data —  json данные телеметрии
   - device_name — имя устройства, с которого пришла запись
   - created_at


Связи между сущностями в системе:
1. **User - Home**:
  - Пользователь владеет одним или несколькими домами.
  - В каждом доме может быть только один владелец

2. **Home - Device**:
  - Дом может содержать несколько устройств.

3. **Device - Sensor**:
  - Устройство может иметь несколько связанных датчиков.

4. **Device - TelemetryRecord**:
  - Устройство генерирует телеметрические записи
  - Каждая запись связана с конкретным датчиком через `device_name`.

5. **DeviceType - Device**:
  - Устройства имеют определенный тип, который классифицирует их 

**1.4 Описание API**
Спецификация OpenAPI генерируется автоматически с помощью фреймфорка gin по описанию методов транспортного слоя.
В каждом сервисе результат генерации расположен в cmd/docs/swagger.json


Описание:
1) Пользователь регистрируется в системе
2) Пользователь регистрирует новое устройство. Устройство проверяется на поддерживаемость в системе
3) Устройство включается вызовом ручки /control/turn_on
4) Данный сигнал отправляется в сервис device-proxy, реализующий протокол устройств
5) Вызывается ручка получения стейта устройства /control/state, которая ходит в telemetry-service для сбора данных телеметрии
6) Далее пользователь отправляет команду через ручку /control/command, которая изменяет текущий стейт девайса на новый
7) Сервис "Управление устройствами" запускает асинхронный процесс регулировки температуры. Который:
   - получает текущий стейт из сервиса телеметрии
   - отправляет сигналы в сервис device-proxy (increase, decrease)
   - и это выполняется до тех пор, пока текущий стейт устройства не будет равен целевому

**Сервис "Управление устройствами"**

- Эндпойнт: `/user/register`
- Метод: `POST`
- Описание: Регистрация пользователя
- Принимает:
  - username — имя пользователя
  - email — почта
  - password — пароль

- Эндпойнт: `/user/login`
- Метод: `POST`
- Описание: Авторизация пользователя
- Принимает:
  - username — имя пользователя
  - password — пароль
- Возвращает:
  - token — токен авторизации


- Эндпойнт: `/devices/register`
- Метод: `POST`
- Описание: Подключение нового устройства
- Принимает:
  - Системное имя устройства "home_temperature"
  - Описание устройства "Регулировка температуры в квартире"
  - Тип устройства: "Light, Heating, Door,  Gates, Temperature"
  - Системное имя дома "home_moscow_123"
  - Имя пользователя "username"
- Возвращает:
  - device_name — системное имя устройства


- Эндпойнт: `/devices/info`
- Метод: `GET`
- Описание: Получение информации по устройству по имени
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя
- Возвращает
  - Системное имя устройства "home_temperature"
  - Описание устройства "Регулировка температуры в квартире"
  - Тип устройства: "Light, Heating, Door,  Gates, Temperature"
  - Системное имя дома "home_moscow_123"


- Эндпойнт: `/devices/list`
- Метод: `GET`
- Описание: Получение всех зарегистрированных устройств по пользователю
- Принимает:
  - username — имя пользователя
- Возвращает
  - список девайсов


- Эндпойнт: `/devices/delete`
- Метод: `GET`
- Описание: Удаление устройства по имени
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя


- Эндпойнт: `/control/on`
- Метод: `POST`
- Описание: Включение устройства
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя


- Эндпойнт: `/control/off`
- Метод: `POST`
- Описание: Выключение устройства
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя


- Эндпойнт: `/control/status`
- Метод: `POST`
- Описание: Получение статуса девайса (вкл/выкл)
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя
- Возвращает
  - status: on, off


- Эндпойнт: `/control/command`
- Метод: `POST`
- Описание: Отправить команду для определения целевого состояния устройства.
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя
  - attributes: { "brightness": 75, "color_temperature": 3000}


- Эндпойнт: `/control/state`
- Метод: `GET`
- Описание: Получить текущее и целевое состояние устройства
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя
  - current_attributes — текущее состояние системы
  - target_attributes — целевое состояние системы

**Сервис "Телеметрия"**

Описание:
Телеметрия поступает через топик кафки device_telemetry_0, обрабатывается и сохраняется в бд TimescaleDB.
Далее пользователи могут синхронно обращаться к сервису через API gateway для получения данных телеметрии.

**Endpoints**
- Эндпойнт: `/last_telemetry`
- Метод: `GET`
- Описание: Получение последней телеметрии по устройству
- Принимает:
  - device_name — системное имя устройства
- Возвращает:
  - telemetry_data — данные телеметрии

- Эндпойнт: `/telemetry`
- Метод: `GET`
- Описание: Получение данных телеметрии по устройству по временному промежутку
- Принимает:
  - device_name — системное имя устройства
  - start_date — начальная дата
  - end_date — конечная дата
- Возвращает:
  - telemetry_data — данные телеметрии

