# **Задание 1.1**

1. Описание функциональности текущего монолитного приложения.

**API**
- **getHeatingSystem** — Получение системы отопления по id
- **updateHeatingSystem** — Обновление системы отопления по id
- **turnOn** — Включение системы отопления по id
- **turnOff** — Выключение системы отопления по id
- **setTargetTemperature** — Установка целевой температуры до tmp для системы отопления по id
- **getCurrentTemperature** — Получение текущей температуры для системы отопления по id

**Текущее монолитное приложение имеет ряд проблем:**
- Нет чётких границ между пользовательским взаимодействием с системой и тем, как система сама выполняет внутренние взаимодействия.
- Синхронное взаимодействие с датчиками. Датчики могут быть временно недоступны, из-за чего вся система будет ждать. Если домов, где расположены датчики, много, то высока вероятность того, что какие-то датчики будут недоступны.
- Синхронное управление температурой. Пользователю не нужно ждать, пока запрос дойдёт до датчика и обратно. В периоды высокой нагрузки, например, во время резких изменений климата или в утренние и вечерние часы, когда пользователи корректируют температуру, могут возникать проблемы с производительностью.
- Одна база данных для всего приложения. Данные для мониторинга и управления отоплением хранятся вместе. Объём данных по температуре может быть в несколько раз больше, чем данных по системам, что может негативно сказаться на производительности.

**Плюсы текущей архитектуры:**

- Удобна для небольшого количества пользователей. Возможно, пока пользователей не так много, сервис будет справляться со своими задачами и не вызывать проблем с производительностью. Не нужно поддерживать большое количество отдельных микросервисов, инструментов масштабирования и оркестрации.
- В текущем приложении мало кода, соответственно, на данном этапе разработка нового функционала осуществляется быстро.

**Минусы текущей архитектуры:**

- Сложность масштабирования. При росте количества датчиков, подключённых к системе, высок риск ухудшения производительности.
- Рост количества запросов в одну часть системы может негативно влиять на другие части. Например, во времена высокой активности при изменении параметров системы отопления могут возникать задержки при получении данных о текущей температуре с датчиков.

### Разбивка текущего монолитного решения на домены

### Домен: Управление системой отопления
Этот домен отвечает за все действия, связанные с управлением системой отопления, включая включение и выключение системы, а также установку и автоматическое поддержание температуры.
- **Поддомен: Управление отоплением**
  Этот поддомен фокусируется на включении и выключении системы отопления. Его задачи связаны с управлением состоянием системы (включено/выключено)
    - Контекст: Включение системы отопления
    - Контекст: Выключение системы отопления
- **Поддомен: Управление температурой**
  Этот поддомен сосредоточен на задачах, связанных с установкой пользователем целевой температуры и её поддержанием системой. Это более сложная задача, потому что система должна не просто включиться или выключиться, а поддерживать заданный уровень тепла.
    - Контекст: Установка целевой температуры пользователем
    - Контекст: Автоматическая регулировка температуры системой
### Домен: Мониторинг температуры
Этот домен отвечает за сбор данных с датчиков температуры и предоставление этих данных пользователям. Он занимается только мониторингом и не вмешивается в управление самой системой отопления (включение, выключение, установка температуры).
- **Поддомен: Сбор данных с датчиков**
  Этот поддомен занимается непосредственно взаимодействием с датчиками, которые установлены в домах пользователей. Его задача — получать данные о текущей температуре.
    - Контекст: Получение температуры с датчиков, установленных в домах
- **Поддомен: Отображение данных пользователям**
  Этот поддомен отвечает за вывод данных о текущей температуре пользователям. Он не вмешивается в работу датчиков, его задача — показать информацию в интерфейсе.
    - Контекст: Отображение текущей температуры на пользовательском интерфейсе (UI)

# **Задание 1.2**

1. **Декомпозиция на микросервисы  V1**

**Домен: Управление системой отопления**

**Контекст: Включение системы отопления, Выключение системы отопления**
**Entities:**
- HomeSystem — объект, представляющий систему отопления в доме.
  **Value objects:**
- HeatingStatus — текущее состояние системы отопления вкл/выкл.
  **Aggregates:**
- HeatingSystem — это агрегат, который объединяет сущность **HomeSystem** и объект-значение **HeatingStatus**.
  **Repositories:**
- HeatingSystemRepository  — интерфейс для доступа к системе отопления
  **Services:**
- HeatingControlService — сервис бизнес-логики управления системой отопления

**Контекст:** **Установка целевой температуры пользователем**
**Entities:**
- HeatingSystem — объект, представляющий систему отопления в доме.
  **Value objects:**
- TargetTemperature — целевая температура системы
  **Aggregates:**
- HeatingSystem — это агрегат, который объединяет сущность **HeatingSystem** и объект-значение **TargetTemperature**.
  **Repositories:**
- HeatingSystemRepository  — интерфейс для доступа к системе отопления
  **Services:**
- TemperatureControlService  — сервис, отвечающий за логику установки целевой температуры

**Контекст: Автоматическая регулировка температуры системой**
**Entities:**
- HeatingSystem — объект, представляющий систему отопления в доме.
  **Value objects:**
- TargetTemperature — целевая температура системы
- CurrentTemperature — текущая температура системы
  **Aggregates:**
- HeatingSystem — это агрегат, который объединяет сущность **HeatingSystem** и объекты-значение **TargetTemperature** и **CurrentTemperature**
  **Repositories:**
- HeatingSystemRepository  — интерфейс для доступа к системе отопления
  **Services:**
- TemperatureRegulationService — сервис, который отвечает за автоматическую регулировку температуры


**Домен: Мониторинг температуры**
**Контекст: Получение температуры с датчиков, установленных в домах**
**Entities:**
- Sensor — сущность, представляющая датчик температуры
  **Value objects:**
- Temperature — температура, указанная на датчике
  **Aggregates:**
- SensorTemperature — это агрегат, который объединяет сущность Sensor и объект Temperature
  **Repositories:**
- SensorRepository  — интерфейс для доступа к датчикам
  **Services:**
- SensorDataService — сервис, который отвечает за получение данных с датчиков

**Контекст:** **Отображение текущей температуры**
**Entities:**
- Sensor — сущность, представляющая датчик температуры
  **Value objects:**
- Temperature— объект-значение, который выводит данные о текущей температуре
  **Aggregates:**
- SensorTemperature — это агрегат, который объединяет сущность Sensor и объект TemperatureInfo
  **Repositories:**
- SensorDataRepository  — интерфейс для доступа к данным полученных с датчиков
  **Services:**
- TemperatureMonitoringService — сервис, который отвечает за отображение данных о температуре

На текущем этапе выглядит логичным следующее разбиение на микросервисы:
- heating-control-service — Микросервис управления системой отопления.
- temperature-provider-service — Микросервис мониторинга температуры

2. Взаимодействие между микросервисами
   В качестве прокси будет использоватьcя APIGateway. Все пользовательские запросы будут проходить через него.
   Сервисы будут взаимодействовать друг с другом через gRPC

Эндпоинты сервиса heating-control-service:
- TurnOn — включение отопления в конкретной системе
- TurnOff — выключение отопления в конкретной системе
- GetHeatingSystem — получение информации по конкретной системе отопления
- SetTargetHeatingSystemTemperature — установка целевой температуры в системе отопления
- GetCurrentHeatingSystemTemperature — получение текущей температуры в системе отопления
  Эндпоинты сервиса temperature-provider-service
- GetSensorTemperature — получить текущее значение температуры датчика
- GetGroupSensorTemperature — получить температуру по группе датчиков. Например, если в квартире их нескольк

Далее, я понял, что нужно поддержать не только систему отопления, но и другие девайсы и сделал другое разбиение на домены

**Декомпозиция на микросервисы  V2**

**Сервис "Управление устройствами"**
Контекст: Регистрация/Удаление девайса в системе
Entities:
- Device — объект представляющий девайс
- User — сущность пользователь
- Home — сущность дома
  Value objects:
- DeviceType — тип устройства
- DeviceCapabilities — объект-значение, который может хранить список поддерживаемых команд и состояний для каждого устройства
  Aggregate
-  Device — аггрегат представленный в виде сущности Device и типа устройства DeviceType
   Repositories:
- DeviceRepository —  интерфейс для доступа ко всем зарегистрированным девайсам в системе
- DeviceConnector — интерфейс для общения с девайсами
  Services:
- DeviceRegistrationService — сервис регистрации/удаления девайсов в системе

**Контекст: Включение/Выключение устройства**  
Entities:
- Device — объект представляющий девайс
  Value objects:
- DeviceStatus — текущий статус (включен/выключен) девайса
  Aggregate:
- Device — аггрегат объединяющий сущность Device и объект-значение DeviceStatus
  Repositories:
- DeviceRepository —  интерфейс для доступа ко всем зарегистрированным девайсам в системе
-  DeviceConnector — интерфейс для общения с девайсами
   Services:
- DeviceControlService — сервис управления девайсами в системе

**Контекст: Установление целевого состояния для девайса**
Entities:
- Device — объект представляющий девайс
  Value objects:
- CurrentDeviceState — текущее состояние девайса
- TargetDeviceState — целевое состояние девайса
  Aggregate:
- Device — аггрегат объединяющий сущность Device, объекты-значение CurrentDeviceState и TargetDeviceState
  Repositories:
- DeviceRepository —  интерфейс для доступа ко всем зарегистрированным девайсам в системе
-  DeviceConnector — интерфейс для общения с девайсами
   Services:
- DeviceControlService — сервис управления девайсами в системе

**Контекст: Автоматическое регулирование состояния девайса**
Entities:
- Device — объект представляющий девайс
  Value objects:
- CurrentDeviceState — текущее состояние девайса
- TargetDeviceState — целевое состояние девайса
  Aggregate:
- Device — аггрегат объединяющий сущность Device, объекты-значение CurrentDeviceState и TargetDeviceState
  Repositories:
- DeviceRepository —  интерфейс для доступа ко всем зарегистрированным девайсам в системе
- DeviceConnector — интерфейс для общения с девайсами
  Services:
- DeviceRegulationService — сервис регулирования состояниями девайсов

**Сервис "Управление телеметрией"**
**Контекст: Сбор телеметрии**
Entities:
- TelemetryRecord — объект телеметрии
- Device — девайс
  Value objects:
- TelemetryData — объект-значение, содержащий конкретные параметры устройства
  Repositories:
- TelemetryRepository —  интерфейс для сохранения данных телеметрии в хранилище.
  Services:
- TelemetryCollectionService —  сервис, отвечающий за сбор телеметрии с устройств и передачу её в хранилище

**Контекст "Предоставление телеметрии пользователю"**
Entities:
-  TelemetryView — сущность, представляющая данные для отображения пользователю.
   **Repositories**:
- TelemetryViewRepository — интерфейс для получения данных телеметрии для отображения пользователю.
  **Services**:
- **TelemetryDisplayService** — сервис для предоставления данных телеметрии в интерфейсе пользователя.


**1.3 Сущности**
Сущности в сервисе "Управление устройствами"
1) User: пользователь системы
- id — идентификатор пользователя
- username
- email
- password_hash
- created_at
- updated_at
- role (admin,user)

2) Home: сущность дома, где будут находиться устройства
- id - идентификатор дома
- name — системное имя дома в виде "home_moscow_123"
- description  — описание дома для отображение на фронтенде
- user_id — айди пользователя, который владеет данным домом
- adress — адрес
- created_at
- updated_at
3) Device
- id — идентификатор девайса
- name — системное имя девайса "temperature_regulator"
- description — описание девайса "Регулирует температуру в доме"
- attributes — атрибуты девайса. Текущее значение параметров, которыми позволяет управлять девайс {"temperature" :  "25"}
- home_id — дом, в котором находится девайс
- status —  статус девайса (вкл/выкл)
- type — тип девайса
- created_at
- updated_at

Сущности в сервисе "Телеметрия"
1) Sensor: датчик, предоставляющий телеметрическую информация
- id — идентификатор датчика
- device_name — девайс, по которому датчик предоставляет информацию
- name — системное имя датчика
- type — тип датчика
- created_at — тип датчика
2) TelemetryRecord: запись телеметрии по конкретному датчика
- id — идентификатор запись
- data —  raw данные
- sensor_id — айди датчика, с которого пришла запись
- created_at
3) TelemetryViewRecord: запись с датчика, преобразованная в читаемый
- id – идентификатор записи
- sensor_id — айди датчика, с которого пришла запись
- telemetryType — тип телеметрии: temperature, brightness, doorStatus, gateStatus
- attributes — преобразованные raw данные в атрибуты
- created_at


Связи между сущностями в системе:
1. **User - Home**:
  - Пользователь владеет одним или несколькими домами.
  - В каждом доме может быть только один владелец

2. **Home - Device**:
  - Дом может содержать несколько устройств.

3. **Device - Sensor**:
  - Устройство может иметь несколько связанных датчиков.

4. **Sensor - TelemetryRecord**:
  - Датчик генерирует телеметрические записи
  - Каждая запись связана с конкретным датчиком через `sensor_id`.

5. **Sensor - TelemetryViewRecord**:
  - Датчик также может создавать записи, которые преобразуются в читаемый формат.

6. **TelemetryViewRecord - TelemetryType**:
  - Запись телеметрии содержит тип телеметрии, например, температура, яркость, статус двери, статус ворот.

7. **DeviceType - Device**:
  - Устройства имеют определенный тип, который классифицирует их 


**1.4 Описание API**

**Сервис "Управление устройствами"**
- Эндпойнт: `/devices`
- Метод: `POST`
- Описание: Подключение нового устройства
- Принимает:
  - Системное имя устройства "home_temperature"
  - Описание устройства "Регулировка температуры в квартире"
  - Тип устройства: "Light, Heating, Door,  Gates, Temperature"
  - Системное имя дома "home_moscow_123"
  - Имя пользователя "username"
- Возвращает:
  - device_name — системное имя устройства

- Эндпойнт: `/devices`
- Метод: `GET`
- Описание: Получение информации по устройству по имени
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя
- Возвращает
  -  Системное имя устройства "home_temperature"
  - Описание устройства "Регулировка температуры в квартире"
  - Тип устройства: "Light, Heating, Door,  Gates, Temperature"
  - Системное имя дома "home_moscow_123"

- Эндпойнт: `/devices`
- Метод: `GET`
- Описание: Получение всех зарегистрированных устройств по пользователю
- Принимает:
  - username — имя пользователя
- Возвращает
  - список девайсов

- Эндпойнт: `/devices
- Метод: `GET`
- Описание:  Удаление устройства по имени
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя

- Эндпойнт: `/devices/on`
- Метод: `POST`
- Описание:  Включение устройства
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя

- Эндпойнт: `/devices/off`
- Метод: `POST`
- Описание:  Выключение устройства
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя

- Эндпойнт: `/devices/status`
- Метод: `POST`
- Описание:  Получение статуса девайса (вкл/выкл)
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя
- Возвращает
  - status: on, off

- Эндпойнт: `/devices/command`
- Метод: `POST`
- Описание:  Отправить команду для определения целевого состояния устройства.
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя
  - attributes: { "brightness": 75, "color_temperature": 3000}

- Эндпойнт: `/devices/state`
- Метод: `GET`
- Описание:  Получить текущее и целевое состояние устройства
- Принимает:
  - home_name — системное имя дома
  - device_name — системное имя девайса
  - username — имя пользователя
  - current_attributes — текущее состояние системы
  - target_attributes — целевое состояние системы

**Описание взаимодействия:**

**Endpoints**
- Эндпойнт: `/telemetry{device_name}`
- Метод: `POST`
- Описание: Cохранение телеметрии

- Эндпойнт: `/telemetry{device_name}`
- Метод: `GET`
- Описание: Получение телеметрии

Описание взаимодействия:
1) Пользователь регистрирует устройство в системе вызовом
   `POST /devices` с информацией по девайсу
2) Включает устройство
3) Получается текущее и целевое состояние устройства. Если целевое состояние не задано, то оно равно текущему
4) С помощью эндпоинта `/devices/command` указывается команда для определения целевого состояния система
5) Система автоматически регулирует текущее состояние системы